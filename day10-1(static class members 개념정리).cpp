// 정적(static) 멤버
//  : 클래스의 멤버변수, 멤버함수에 정적인 성격을 의미하는 예약어 static을 붙여 선언부에 작성한 경우
//     -> 해당 클래스의 static 멤버변수는 클래스 {} 안에서 통용되는 일종의 전역변수로서 모든 객체들이 공유하는 공용값의 성격을 지닌 변수로 작동함
//        (= 전역변수와 마찬가지로 main 함수가 호출되기 전에 메모리 공간에 올라가서 초기화 됨)
//           -> (중요!) 객체 생성과는 관계 없이 먼저 할당됨을 의미 = 각 인스턴스 별로 따로 특성이 만들어지지 않음

//   # 정적 변수(static) 복습 : 컴파일 시 데이터 영역에 메모리(RSS)가 할당, 프로그램이 종료될때까지 값을 유지 (단! 자기 프로그램 내에서만 참조 가능)
// 
//      -> 자동 초기화 ㅇ (프로그램 시작시, 딱 1번만 초기화 = 변경값은 끝까지 저장)
//          -> 생존기간  : forever
// 
//      -> 세부구분
//          - 2.1 외부 staric 변수
//              : 함수 밖에서 선언되는 일반 static변수 (사실상 전역변수와 유사)
//          - 2.2 내부 static 변수
//              : 함수 안에서 선언되는 지역변수와 같은 static변수...  (그러니까 다른 {}차원에 존재하는 static변수)
// 
//       -> (중요) 자동변수(auto)와의 비교
//          - 공통점 : 지역변수
//          - 차이점 : 함수 실행 때마다 초기화 되는 자동변수와 달리.. 해당 함수가 실행될 때만 변동이 생기지만, 변경값은 끝까지 저장..

//   # 정적(static) 멤버 호출법
// 
//      - 정적(static) 멤버변수
//         : 클래스명::멤버변수;
// 
//      - 정적(static) 멤버함수
//         1. 클래스명::멤버함수(parameters..);          <- 'namespace명::식별자'와 사용법이 근본적으로 같음 (걔네도 내부는 일종의 연산자 형식의 함수로 되어 있을거라 생각)
//         2. class객체명.멤버함수(parameters..);

//   # (c++ 추가 + 중요) c++에서 :: 연산자
//     : scope resolution 연산자 (namespace, class, struct 등 자기 영역(scope)이 있는 자료형의 경우, 그 특정 자료형 안의 멤버(변수, 함수 다 포함)를 찾아 참조하라는 의미)
//       -> (결론) namespace명::식별자, 구조체명::멤버함수(), 전부 같은 맥락으로 이해하면 됨
//            -> BUT! 'namespace명::식별자', 'class명::static멤버변수 or static멤버함수' 는 호출이나 참조하는 기능에 가까움     <->    구조체명::멤버함수()는 '함수 정의부'에 쓰임 ( <-> 참조는 구조체 or 클래스 변수명.멤버함수() )

//   # 정적(static) 멤버변수 특성
//     - (공통) 
//        1. 일종의 클래스 전역변수, 전역함수 = main 함수가 호출되기 전에 메모리 공간에 올라가서 초기화되는 전역변수의 특성 가짐
//           -> (중요!) 객체 생성과는 관계 없이 먼저 할당됨을 의미 = 각 인스턴스 별로 따로 특성이 만들어지지 않음
//        2. 해당 클래스를 기반으로 생성된 모든 객체가 공유 가능함
//        3. 접근제어자를 통해 마찬가지로 제어가능
//        
//     - (static 멤버변수)
//        1. C++에서는 반드시 전역 스코프 영역에서 미리 선언 및 초기화를 해줘야 에러가 나지 않음 
//           -> Why? (중요) 애초에 C++에서는 클래스의 멤버변수를 선언할 때 초기화 값을 대입하는거 자체가 허용 X
//               ex) 자료형 클래스명::멤버변수 = 값; 형식으로 선언 및 대입 -> int CLASS_EX::members = 0;
// 
//     - (static 멤버함수)
//        1. (중요!) 정적 멤버함수는 같은 클래스 안의 static 멤버 변수, 정적 멤버함수만 접근 및 호출이 가능함 
//           -> 클래스의 객체 모두가 공유하는 함수이기에, 공유하는 것들만 당연히 접근 및 호출해야 함 (사용 조건이 빡센건 얘만 해당)

// static을 사용한 클래스 멤버변수 및 함수 예시코드
#include <iostream>

using namespace std;

// x,y 좌표를 가지는 포인트 클래스
class Point_1 {

    private:

        int x, y;

        // (타 영역에서 호출불가능) Point_1 클래스의 static 멤버변수 creat_cnt
        //   -> class Point_1의 생성자 함수를 실행하면, 증가하게 설계
        static int creat_cnt;

    public:

        // (타 영역에서 호출가능) Point_1 클래스의 static 멤버 call_cnt
        //   -> static 멤버함수c OutPointCount()를 실행하면, 증가하게 설계
        static int call_cnt;

        Point_1(int _x, int _y) : x(_x), y(_y) {
            creat_cnt++;
        }

        // Point_1 클래스의 static 멤버함수 선언부
        //  -> static 멤버변수 관련된 것만 다룰 수 있음
        static void OutPointCount(); 
};

// C++에서 static 멤버변수들은 반드시 전역스코프에서 선언 및 초기화 필수 <-> 클래스에서 static 멤버변수를 선언할 때 초기화하는거 자체가 C++은 허용 안 함
//  -> 자료형 클래스명::멤버변수 = 값 형식으로 선언 및 대입
int Point_1::creat_cnt = 0, Point_1::call_cnt = 0;

void Point_1::OutPointCount() {//정의부
    call_cnt++;
    cout << "생성된 Point_1 는 " << creat_cnt << "개 입니다.\n";
    cout << "Point_1 호출 횟수는 " << call_cnt << "개 입니다.\n";
}

int main() {

    // 정적(static) 멤버변수 호출 = 클래스명::멤버변수;
    cout << Point_1::call_cnt << "회 호출" << endl; //객체 생성 전에 사용 가능한 멤버

    Point_1 p1(10, 10);

    // static 멤버함수는 '객체명.static멤버함수()' 식으로도 호출됨
    p1.OutPointCount();

    Point_1 p2(20, 20);
    p2.OutPointCount();

    Point_1 p3(30, 30);
    p3.OutPointCount();

    p1.OutPointCount();

    cout << endl;

    // 클래스명에 ::연산자를 통해 직접 호출하는 것도 가능함 
    Point_1::OutPointCount();
    cout << Point_1::call_cnt << " = static변수 직접 호출" << endl;


    return 0;
}
