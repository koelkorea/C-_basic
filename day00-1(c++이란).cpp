// c++
//  : C언어의 확장판에 해당하는 언어로 C언어의 기능들을 추가하고 개선한 언어

//   # 추가 및 개선점
//     1. 객체지향(캡슐화, 상속, 다형성, 추상화) 기반 코드 작성 가능
//        -> new / delete 동적할당
//        -> class (클래스 = 표현할 정보의 종류 & 동사적 기능)
//     2. 함수 오버로딩(함수명 같으나 파라미터의 타입이나 총 숫자가 다른 함수) 사용 가능
//     3. defalut parameter를 사용 및 이를 통한 오버로딩 간략화 가능
//     4. 참조와 참조변수 & 추가
//     5. 참조에 의한 호출 (call by reference) 가능
//     6. 코드 중간에 변수 선언 가능 (원래의 C는 불가능함)
//     7. 연산자 재정의가 가능
//     8. 컴파일 방식 변경 
//        -> 소스(c++) - 전처리 - 컴파일 - 어셈블리 - 링킹 -> 기계어

// *.cpp
//  : c++ 파일 확장자, 이 파일에는 'main' 함수가 기본적으로 포함됨

// 표준 템플릿 라이브러리(STL, Standard Template Library)
//  : C++에서 사실상 템플릿들을 사용하여 작성된 class와 function들이 모인 표준 라이브러리
//    (= function 템플릿, class 템플릿을 사용해 overloading이 필요한 function, class들의 집합)
//       -> 템플릿에 대한 내용은 day 18을 참고 


// 알고리즘(Algorithm)
//  : 정렬, 검색, 비교 등의 작업을 어떻게 수행할 것인가에 대한 방법론
//     -> 정렬, 검색, 비교 등의 기능을 수행하기 위해 짠 함수를 알고리즘 함수라고 명명 
//         -> STL에서는 <algorithm>에 잘 존재함


// 컨테이너(Container)
//  : 여러 개의 요소를 담을 수 있는 데이터 구조를 제공하여 데이터를 저장하고 관리하는 자료구조를 말하는 개념
//     -> 이를 구현해 둔 객체를 쓰면, 데이터의 삽입, 삭제, 검색 등 다양한 작업을 수행 가능 
//         -> 더 구체적인 내용은 day15를 참고


// 이터레이터(Iterator : 반복자, 포인터)
//  : 컨테이너 class 객체라면 배열, 연결리스트, 큐 등 다형성(컨테이너 or 알고리즘)에 얽매이지 않고, 공통의 인터페이스(= 조작체계)를 제공하여 접근 및 순회가 가능하도록 하는 '컨테이너 클래스 내부에 공통적으로 존재하는 class이자 고정 생성된 내부 class객체' 개념
//    (= 쉽게 말해, 컨테이너 class 계보에 속해 있다면, 컨테이너 클래스 내부에 공통의 표준화된 내부 class 구조를 사용하여 [C++에서는 유사 포인터를 통한] 내부 요소 참조 및 순회를 가능하게 한다는 것)
// 
//     -> 내부 클래스 'Iterator class'의 존재 의미 
//         : 컨테이너 클래스 내부에 존재하는 클래스 = 컨테이너 클래스 객체 내부의 개별 데이터의 위치를 측정하는 이터레이터 클래스 자신의 멤버변수와 그 위치의 값을 참조, 순회가능하게 하기 위한 멤버함수가 존재함 
//            -> BUT! 클래스 자체는 객체로 구현되지 않으면, 바로 기능으로 사용할 수 없음
// 
//     -> 내부 고정 클래스 객체 'Iterator class 객체'의 존재 의미
//         : 컨테이너 클래스 내부의 이터레이터 클래스를 객체화하여 Iterator라는 멤버변수로 미리 객체로 생성해 두어, 본래 의도한 컨테이너 내부 데이터 순회 참조 기능이 가능하게 함
//           (= 어떤 종류의 컨테이너 class 객체라도 Iterator라는 이름의 멤버변수를 통해, 그 개별 데이터의 위치를 알 수 있고, 그 컨테이너 클래스의 멤버객체인 Iterator 객체 자신의 멤버함수를 통해 위치를 바꿀 수 있음)
// 
//     -> C++에서 구현된 이터레이터 구조
//         : 포인터와 비슷한 구조로 설계됨 <-> 타언어에서는 포인터 개념을 쓰지 않으니 다를 수 있음
//           (= C++에서는 컨테이너 class 객체의 데이터의 위치값을 저장하는 멤버변수는 일종의 '유사 포인터'라는 것이고, 순회에 필요한 위치값 연산도 포인터의 연산법칙과 유사)


// 함수 객체(Function Object)
//  : C++에서 함수처럼 동작하는 객체 (struct이건 class건 상관없음)
//     -> 정확히는 해당 struct이나 class의 객체를 생성하고, 생성자 함수를 호출하면 함수호출 연산자인 operator()가 자동으로 작동하게 되는 성질을 가진 객체
//         -> 따라서 그 operator() 함수의 내용을 overload하여 해당 객체는 사용자가 원하는 의도의 함수처럼 사용이 가능함
//             -> 연산자 함수에 대한 더 구체적인 내용은 day17를 참고