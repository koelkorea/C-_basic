// 객체지향 패러다임
//  : 현실 세상에 존재하는 사물과 대상, 그 대상의 행동을 객체로 바라보는 사고를 통해 실체화 하는 프로그래밍적 사고방향

//   # 클래스 (= 객체의 틀)
//     : 일종의 함수까지 품을 수 있는 확장형 구조체
//        -> 목적에 따라 대상을 설정하고,
//            -> 그 대상의 속성 = 멤버변수로 선언하여 추상적인 개념을 수치화 가능하게 설계
//            -> 그 대상의 동작 = 멤버함수로 선언 및 정의하여, 수치화된 멤버변수 데이터의 연산을 처리할 수 있도록 설계함

//               ex) class Car { private : int enginePower; int numOfWheel; string maker; int stiringPower; public : int accelerate(enginePower){ ... }; void cornering(stiringPower); }

//   # 객체란?
//     : 1개 이상의 데이터(자료)와 1개 이상의 기능(메소드 : 함수)을 가진 일종의 확장형 구조체 class 자료형을 기반(= 템플릿, 설계도)으로 메모리 상에 만들어진 실체(= instance)


// 캡슐화(Encapsulation)
//  : 객체의 속성(data)과 행위(methods)를 하나로 묶는 행위 (= 클래스 설계)
//     -> (중요) 이 과정에서 공개할 멤버와 숨길 멤버를 정해둘 수 있음 (= 은닉화) 

//   # getter, setter 디자인 패턴
//      : private 접근제어자를 통해 class의 멤버변수의 값에 다른 객체에서의 직접적인 접근 및 변조가 불가능하도록 방지하고, 
//        public 접근제어자로 노출된 인터페이스(= 멤버 함수)를 통해 이를 조작하도록 하는 OOP의 캡슐화 개념을 구현한 대표적 패턴 


// 은닉화(Information hiding)
//  : class의 실제 구현 내용을 접근제어자를 통해 접근제어 권한에 차등을 둬서 외부에 숨기는 개념
//    -> (중요) 은닉화는 캡슐화를 구현하는 과정에 포함된 부분기능 같은 개념이라 생각하면 됨 ( 캡슐화 > 은닉화 )

//   # 접근제어자
//      : 클래스의 멤버변수의 변조 방지를 위해 코드 실행 중 접근위치에 따라 멤버변수의 값에 접근여부에 따른 제어권한을 의미 
//         -> 사실상 public과 private만 널리 사용되며, 이들이 getter setter 디자인패턴과 연관 

//        - private     : 해당 클래스 내에서만 해당 클래스의 멤버들에 접근할 수 있음 
//                        (= 오로지 클래스 선언시 미리 작성한 멤버변수 초기화 값과 멤버함수를 통해서만 값의 변조가 가능 == 은닉이 필요한 속성에 적용하게 됨)
//      
//        - protected   : 상속관계에서 해당 클래스의 멤버들에 접근허용 
//                        (= 해당 클래스와 상속관계에 있는 클래스가 선언될 때라면, 해당 멤버변수의 값에 접근 및 변조나 멤버함수의 사용이 가능) 
//      
//        - public      : 어디서든 일단 멤버변수나 멤버메서드가 호출되거나 참조되면, 언제라도 해당 멤버변수의 값에 접근 및 변조나 멤버함수의 사용을 허용함 (사실상 자동문임)