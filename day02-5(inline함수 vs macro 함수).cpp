// inline 함수
//  : if 함수를 선언시 inline을 붙힌다면? 
//     -> main영역에서 함수 부분의 호출부에 대한 처리가? 
//        -> (기존 함수 처리) 코드를 '실행' 시, 함수 호출 코드를 발견하면
//            : 함수가 선언된 부분을 찾아서 stack영역에서 정의된 내용을 실행 후, 그 리턴갑을 가지고 그 호출 위치에 다시 돌아와서 진행
//        -> (inline 사용시) 코드를 '컴파일' 시, 함수 호출 코드를 발견하면
//            : 함수 정의부분(= 파라미터와 그 함수 내용 전체)의 코드 그 자체가 호출된 코드 위치에 복사(호출 횟수 × N번 복사)되어 덮어씌어진 뒤, 컴파일을 계속 진행함 
// 

//  # inline 함수 특징
//    1. 함수의 정의부가 간단한 경우 선언해야 효과가 있음 
//       -> 해당 내용이 너무 길면, 용량으로 보나 컴파일 시간으로 보나, 실행 시간으로 보나 안 좋은 일만 가득 (= 사람이 코드를 중복작성 안 해도 된다는거 말곤, 함수부를 나눠놓은 이유 자체가 사라짐..)
//    2. 따라서 inline 함수의 코드 부분이 너무 큰 경우에는 사용자가 inline으로 지정해도 컴파일러가 무시함
//    3. 때때로 inline함수에서 일반함수(inline으로 선언되지 않은 함수)를 호출할 때도 컴파일러가 무시함 (= 보통 그렇게 쓴 코드는 역시 용량으로 보나, 실행속도로 보나 재귀를 쓰는거보다 비효율적이기 때문)
//    4. (주의) 내부연결(internal linkage)을 갖기 때문에, 파일들을 연결해서 쓸거면 반드시 헤더파일에 작성해야 함
//    5. 컴파일러에 의해 처리

//  # 일반 함수 호출 과정 (이해를 돕기 위해)
//    1. 매개변수를 스택(Stack)에 저장(매개변수 전달)
//    2. 함수 호출명령 바로 다음 명령의 주소를 스택에 저장(호출한 곳으로 다시 돌아오기 위해)
//    3. 함수가 정의된 주소로 점프, 함수 코드를 수행
//    4. 리턴 값을 저장
//    5. (2)에 저장해 둔 주소로 돌아옴

//  # macro vs inline
//    : 매크로 함수는 컴파일 되기 전에 전처리기에 의해 처리됨 (= 단지 작성된 코드를 암호처럼 풀이해서 치환할 뿐.. = 반드시 괄호를 써서 잘못된 우선순위연산을 방지해야..)
//      -> 그럼에도, 연산식 중에 괄호를 쓴다고 해도 원치 않는 결과를 초래 함(= macro는 걍 쓰지마.. 괄호를 써도 답이 없거든..)
//         -> macro와 같이 일반코드 치환의 효과를 내면서, 함수의 call by value와 연산식에 유리하단 이점 살리고 싶어 만든게 inline 함수

#include <iostream>
#define SUM(a,b) ((a)+(b))
#define SQ(x) ((x)*(x))
#define MUL(a,b) ((a)*(b))

using namespace std;

// 컴파일러에 의해 처리되는 inline함수를 이용
inline int square(int x) {
	return x * x;
}

int main() {

	// -----------------------------------[메크로 func 사용]-------------------------------
	int n = 3;

	cout << "(3 + 4) * 5 = " << SUM(3, 4) * 5 << endl;
	cout << "(1 + 2) * (3 + 4) = " << MUL(1 + 2, 3 + 4) << endl;

	// 매크로 함수를 쓴 결과 (= 연산이 아니라.. 치환을 해버린 결과)
	//  -> SQ(++n) => ( (++n) * (++n) ) 로 치환
	//  -> 1항에서 n+1, 2항에서 또 n+1을 해버림 ... 
	//  -> 3 -> 4 -> 5로 n이 변하고.. 결과적으로 5를 제곱해버린 25가 나옴
	cout << "macro : " << SQ(++n) << endl;

	// -----------------------------------[인라인 func 사용]-------------------------------
	n = 3;

	// inline처리된 square를 사용
	//  : 컴파일 단계에서 square(int값)을 호출하는 내용을 만날 시, 그 파라미터와 내용(= 정의부)에 대한 부분까지 call by value 형식으로 호출된 위치에 놓고 컴파일까지 해버림
	//    -> 컴파일 중 square(++x)을 만나면, 
	//    -> 그 자리에 parameter : ++n를 복사한 값 , return은 '복사값' * '복사값' -> 이런 형식을 따르는 내용 자체에 해당하는 코드 내용을 끼워넣고 컴파일함
	//       -> 결과적으로 메크로 함수의 문제점을 해결하면서 실행 성능을 향상.
	cout << "inline : " << square(++n) << endl;
	
	return 0;
}
