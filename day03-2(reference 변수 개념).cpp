// Reference 변수
//  : C++에서 기존 선언한 변수에 또 다른 이름을 붙여 이 둘을 페어링 하는걸 Reference라고 함
//    (= 변수와 reference는 완전히 같다고 생각해도 무방... 그냥 다른 이름으로 특정변수와 완전 동기화 되는 레플리카를 만들었다 생각하면 편함)

//     ex) 선언 및 사용 예시
//         int a = 3;     <- a는 3으로 초기화
//         int& r = a;    <- reference r은 변수 a의 메모리를 공유 (= r의 증감 == a의 증감.. 순서는 상관없음)
//         ++a;           <- a == 4
//         ++r;           <- r == a == 5    (중요!) 변수와 reference는 완전히 같다고 생각해도 무방하다.


//  # reference와 pointer의 차이
//    : C에서 사용한 포인터의 역할의 확장판
//      -> 메모리 접근의 가능성면에서 원본 변수의 값과 주소값을 완벽하게 동기화해서 모방하는 reference가 더 직관적이고 간편하게 사용이 가능함
//         (= 이 녀석이 함수의 parameter 선언되어 일반 변수를 넘기데 되면, 그때는 call by reference 개념으로 주소값과 역참조된 값 그 자체를 넘기게 됨)

//  # C++언어 사용 배경
//    : C언어는 변수에 한 개의 이름만을 부여하나.. 
//      -> C++에서는 변수에 여러 개의 이름을 부여 가능 (= 서로 다른 이름으로 같은 변수에 접근 가능)

//  # Reference 변수의 특징
//    1. reference 선언 시, & 연산자를 씀 
//        <-> pointer 선언시에는 * 연산자를 씀 
//    2. 선언과 동시에 반.드.시 초기화되어야 함
//    3. 리터럴 상수(1, 2, 3, …)는 reference 대입할 수 없음

//  # * 연산자 vs & 연산자 정리
// 
//     - * 연산자의 용도
//       1. 곱하기 부호
// 
//       2. 포인터 선언
//          : 타입명 * 변수명; 
//            ex) int * ip;  double* ip;
// 
//       3. 포인터변수 역참조하는 값
//          : * 포인터변수명
//            ex) *ip; *dp;

//     - & 연산자의 용도
//       1. 변수의 포인터(= 메모리 주소) 값
//          : & 변수명
//            ex) &a; &input;
// 
//       2. reference 변수 선언
//          : 타입명 &변수명
//            ex) int &s = a; double &d = input;


// 우리가 poiner가 아니라 reference를 써야 하는 이유?
//  : reference 변수는 그 자체가 모태가 되는 원본 변수의 주소값까지 가지고 있는 변수임을 착안
// 
//    -> 이점1)  함수 선언시에 parameter로 reference변수를 타입으로 선언하는 경우, 변수를 대입할때 그 값을 call by reference 개념으로 주소값에 존재하는 값 그 자체를 넘기게 됨
//               (= 포인터 개념을 생각하지 않기에, call by reference라는 목적만 기억하면 다른 시행착오 없이 깔끔하고 쉽게 함수 선언이 가능하다!..)
//                   -> (중요!) 해당 함수가 받는 param은 reference 변수지만, 호출할때 대입하는 param은 깔끔하게 일반 변수로 해도 무방하다.. 
//                             (= 쉽게 말해, 굳이 다른 reference 변수를 만드는 수고를 안해도 된다 이말이다..)        
// 
//       이점2) 포인터를 쓰면 포인터 연산을 통해 메모리공간을 자유롭게 활보가능 = 쓰는 사람의 혼란을 야기..
//              (= 하지만 특정 변수의 위치값만을 의미하는 reference변수는 죽었다 깨어다도 그 주소외의 다른 주소를 쓸수는 없음)

//   # (중요) reference 변수의 단점
//     : 포인터 연산이 불가능해, 배열이나 문자열 같은 필연적으로 메모리 공간을 여러개를 쓰는 자료형을 다루기는 불편함


// reference 변수 설명 
#include <iostream>
using namespace std;

int main() {

	int a = 100, b = 200;
	
	// pointer변수 p = a의 메모리 주소
	int* p = &a;

	// reference 변수 r = 동기화된 a의 레플리카
	int& r = a;

	// reference 변수와 원본 변수는 값과 주소가 완전 동기화됨
	cout << "a의 주소 =" << &a << endl;
	cout << "r의 주소 =" << &r << endl;
	cout << "p의   값 =" << p << endl;
	cout << "p의 주소 =" << &p << endl;

	//cout << " a = " << a << endl;
	//cout << " r = " << r << " (= 레퍼런스 변수 r은 변수 a의 레플리카) " << endl;
	//cout << "*p = " << *p << " (포인터 p 가 가진 메모리주소 = 변수 a의 주소값) " << endl << endl;

	++a;

	cout << " a = " << a << " r = " << r << " (레퍼런스)" << " *p = "  << p << " (포인터 p가 가리키는 값) " << endl;

	++r;

	// reference 변수와 원본 변수는 사실상 같은 메모리의 값을 가르키고 있기에, 둘의 증감은 서로에게 동기적 영향을 줌 (= 그냥 둘은 같다!)
	cout << " a = " << a << " r = " << r << " (레퍼런스)" << " *p = " << p << " (포인터 p가 가리키는 값) " << endl;


	// reference 변수는 다른 변수로 변경 불가
	r = b;
	cout << " a = " << a << " r = " << r << " (레퍼런스)" << " *p = " << p << " (포인터 p가 가리키는 값) " << endl;

	return 0;
}
