// 생성자(Constructor)
//  : 객체의 [생성]과 동시에 호출하는 '클래스명'과 동일한 이름의 함수, 객체의 동적할당 연산자인 new와 함께 사용하며 초기화 과정의 편리함까지 더해줌
//    -> 원래 calloc, malloc, realloc를 대체한, 'new 클래스명'는 사실 'new 클래스명()'과 같은 의미인 기본 생성자(default Constructor) 함수 
//       (= 생성자 개념이 더 큰 개념 포함)


//   # 생성자 함수를 사용하는 이유?
//     : 동적할당 + 멤버변수 초기화가 필요한 기존의 방식 -> 생성자 하나로 그 두가지를 전부 원큐에 처리하는 방법으로 변경 + 기존 방법도 호환가능하게 변경
//     
//       - 단순 클래스 객체만 동적할당하는 기능만 활용한 기존의 방식 
//          1) class를 기반으로 한 객체를 메모리에 반영구적으로 동적할당 한뒤, 그 주소를 class 포인터 타입인 인스턴스변수에 대입
//          2) 해당 class 기반 객체의 멤버변수들을 직접 값을 넣던, setter를 쓰던 초기화함
//
//       - 생성자 함수를 활용한 기존의 방식 
//          : 멤버변수에 넣고 싶은 값을 생성자 함수 형식에 맞게 대입하면, 알아서 그 내용을 기반으로 한 class를 기반으로 한 객체를 메모리에 반영구적으로 동적할당 한뒤, 그 주소를 class 포인터 타입인 인스턴스변수에 대입함
//             -> 기존의 방식은 default constructor로 편입시켜 받아들임


//   # (중요) 생성자 특징
//     1. (공통) 멤버변수 값을 대입하는 void 함수와 비슷 (= return값 X)
//     2. (공통)가만히 있어도 parameter 없는 기본 생성자(defalut constructor)는 존재
//        -> 단! 정의부는 비어있으니, 내용은 알아서 필요하면 채워야 함
//     3. 생성자는 오버로딩(Overloading) 가능함 
//        (= parameter 구성에 따라 이론상 무한개의 생성자함수 선언도 가능)
//     4. 초기화 리스트(Initialize List) 
//         : 생성자 뒤에 콜론(:)을 사용해서 각 멤버를 초기화 할 수 있음 
//            -> (주의!) 일반 멤버함수에서는 사용 X
//     5. 객체 생성시 딱 한번 호출
//     6. (중요!) new 연산자와 함께 쓰이므로, 반드시 class 포인터변수에 대입되어야 함


//   # 생성자 함수 선언, 정의법
//
//      1. 일반적인 초기화 방법 
//          : 그냥 void 함수라고 생각하되, 생성자 함수의 존재의의 자체가 생성된 객체의 멤버변수 초기화에 있다고 생각하면 편함
//             -> 클래스명(자료형 parameter명...) { 멤버변수 = parameter 사용하거나 가공한 값 }											
//                       
//                ex) class A 멤버는 다음과 같다 가정 ( int a; double b; char c; )
//                    
//                    A (int _a, double _b, char _c) {
//                        a = _a;
//                        b = _b;
//                        c = _a;
//                    }
//
//      2. 초기화 리스트(Initialize List) 
//          : (중요!) 콜론(:)을 이용하는 초기화법, 정의부보다 우선하여 실행된다는 장점이 있어, const 멤버변수의 초기화에 쓰임                        
//             -> 클래스명(자료형 parameter명...) : 가담O 멤버변수(parameter명) , ...  { 가담X 멤버변수 = parameter 사용하거나 가공한 값 }												
//                                                            
//                ex) class A 멤버는 다음과 같다 가정 ( int a; double b; char c; )
//		          
//                    A (int _a, double _d, char _c) : a(_a), c(_c) {
//                        b = _b;
//                    }


//   # 선언, 정의한 생성자 함수 종류 및 호출법
//
//      1. defalut constructor
//
//        - defalut constructor 정의
//           : (중요!) class에 아무것도 안 적어도 무조건 기본으로 존재하는 parameter 없는 생성자함수
//              -> 단! 정의부는 비어있기에, 내용이 필요하면 채워야함
//
//        - defalut constructor 호출법
//           : 클래스명 * 클래스포인터명 = new 클래스명;     
//             클래스명 * 클래스포인터명 = new 클래스명();   
//
//             ex) point* ptr_pos_1 = new point;
//                 point* ptr_pos_1 = new point();
//
//      2. (일반) constructor
//            
//        - (일반) constructor 정의
//           : defalut constructor 이외, 오버로딩한 생성자 함수 (= parameter 구성에 따라 이론상 무한개의 생성자함수 선언도 가능함)
//              -> 보통은 parameter를 멤버변수 값으로 대입하기 위해 사용
//
//        - (일반) constructor 호출법
//           : 클래스명* 클래스포인터명 = new 클래스명(parameter....);   
//
//             ex) point* ptr_pos_1 = new point(1, 1); 


//   # 관련 의문내역 해설

//     1. 클래스명 인스턴스변수명;  vs  클래스명* 클래스포인터변수 = new 클래스명; 의 차이는 뭘까? 
//        : 인스턴스변수명이 저장하는 class의 객체 내용이 지역변수나 객체로서 {}가 끝나는 순간 사라지느냐? or 아니면 일종의 전역객체로서 데이터가 할당 해제나 프로그램 종료가 되기전까지 남아있냐?
//           -> (중요) 이에 대한 다른 언어 개발자 입장
//                : 포인터로 선언하고 복잡하기까지 한 동적할당은 ㅈㄴ 싫음, BUT 생성자 함수의 객체생성 + 초기화의 편의성은 누리고 싶음
//                    -> 생성자 함수의 반환값을 클래스타입으로 만들어서, 포인터 없이 class 인스턴스만 선언해도 생성자를 사용 가능하게 함(물론 동적할당의 이점과 단점 전부 없음) + 선언한 '인스턴스변수명'으로 접근가능하게 해주는 식으로 타협을 마침

//     2. 클래스명 인스턴스변수명(parameters...); 방식으로 생성자 함수는 그럼 사용이 불가능한가?
//        : 사용은 가능하나... 문제는 마찬가지로 그렇게 생성되고 초기화 된 class기반 객체가 지역객체이기에 그 한계인 {}가 끝나는 순간 사라지는게 문제가 되는 것일 뿐

//           ex) point pos_1(1, 1);                    <- 해당 {}가 끝나는 순간 사라짐 (= 일반함수에서 생성 후 계산 후 보관해서 써먹겠다는 발상이 불가능
//               point* ptr_pos_1 = new point(1, 1);   <- 메모리에 사용자 임의로 동적할당해놓으라고 했기에, 



// 소멸자(Destructor)
//  : 객체의 [소멸]과 동시에 호출되는 '~클래스명'이란 이름의 함수, 이를 통해 'delete class객체포인터(= 객체위치 저장한 class포인터변수)'로 동적할당된 클래스 자신의 메모리 영역을 해제하면서, 다른 내용도 수행가능해짐
//     -> (중요!) 
//         1. 단! 직접 '~클래스명'를 호출해서 사용하지 않음!
//         2. class에 아무것도 안 적어도 무조건 기본으로 존재는 하는데, 멤버변수도 동적할당된 자료형이 있어서 해제해야 한다면, 정의부에 따로 delete 멤버변수 관련 내용을 적어줘야 함
//         3. 오버로딩은 불가능해, 무조건 한가지의 소멸자만 있어야 함


//   # 소멸자 함수를 사용하는 이유?
//     : 멤버변수 중 동적할당 받은 객체와 연관되어 있는 특정 class의 포인터가 있다면, 하나하나 다 delete를 입력노가다 해야 하는 기존의 방식 
//        -> 소멸자 함수로 정의부에 동적할당된 주소값을 담는 특정 class의 포인터인 멤버변수 전부를 delete 처리하게 작성하면, class객체가 삭제될때 관련 내용들이 싹 다 사라짐


//   # (중요) 소멸자 특징
//     1. (공통) 멤버변수 값을 대입하는 void 함수와 비슷 (= return값 X)
//     2. (공통) 가만히 있어도 parameter 없는 기본 생성자(defalut constructor)는 존재
//        -> 단! 정의부는 비어있으니, 내용은 알아서 필요하면 채워야 함
//     3. 객체 삭제시 딱 한번 호출
//     4. parameter는 존재할 수 없음 (= 단 1개의 소멸자인 default 소멸자만 존재해야 함)
//     5. (중요!) 객체의 유효범위 = 지역변수의 유효범위 
//         -> 블록{}가 끝나게 되면, 자동으로 소멸자가 실행됨 (= 메모리 상에서 소멸됨)
//     6. (중요!) 직접 클래스를 호출하는 방식이 아니라, 'delete class객체포인터' 형식으로 실행됨 


//   # 소멸자 함수 선언, 정의법
//      : 그냥 void 함수라고 생각하되, 생성자 함수의 존재의의 자체가 생성된 객체의 멤버변수 초기화에 있다고 생각하면 편함
//         -> ~클래스명() { delete 멤버변수(동적할당 위치 담은 포인터인 멤버변수); }											
//                   
//            ex) class A 멤버는 다음과 같이 classCreated라는 class가 동적할당되어 있는 주소값을 가지는 포인터를 멤버변수로 둔다 가정 ( int a; classCreated* b; char c; )
//                
//                ~A () {
//                    delete b;     <- delete A의객체; 를 입력시 포인터변수인 b에 입력된 주소값에 할당된 메모리도 같이 회수함(= 잘못쓰면 연쇄 삭제 일어남..)
//                }


//   # 선언, 정의한 소멸자 함수 호출법
//      : 그냥 delete class객체포인터을 실행시 {}안에 내용도 실행해주는 void 함수라고 생각하자 (= 안 써도 해당 객체 자체는 메모리에서 해제해 줌)
//         -> delete class객체포인터;


//   # (중요!) delete 기초 사용법
//     : delete 포인터 = free(포인터)
//        -> 해당 포인터에 존재 및 연계된 포인터가 가르키는 동적할당된 객체를 제거 (애초에 동적할당을 받을떄도 포인터로 받은 위치로 구분했으니 당연한 것)


//   # 생성자 VS 소멸자 정리

//     |===========|=============================================|=====================  
//     |           | 생성자                                      |    소멸자
//     |===========|=============================================|=====================  
//     | 호출시기   | 객체 생성시 1번만                            | 객체 소멸 시
//     | 함수명     | 클래스명                                    |  ~클래스명
//     | 리턴값     | X                                           | X
//     | 매개변수   | O (0-N개 = 생성자 오버로딩 가능)              | X (= 오직 1개만 존재)
//     | 활용       | CLASS의 멤버변수 초기화 시                   | 동적 메모리 해제 시
//     | 사용법     | class명 인스턴스 = new class명(parameter..); | delete 인스턴스(= 포인터변수)
//     |===========|=============================================|=====================  


//   # (부록) 후기언어에서 C언어식 동적할당 이슈
//     1. 왜 후기언어에서는 왜 C계열 언어의 자료형 동적할당 자체를 배제해버렸는데?
//        : 사용자가 임의로 메모리에 직접 데이터를 새겨넣을 수 있다는건 좋고, 메모리 위치만 알면 값을 대조할 수 있다는것도 좋음
//           -> 근데 문제는 내가 할당한 공간을 내가 하나하나 다 회수하는 명령어도 같이 고려해야 하는데, 이거 복잡해지면 나중에는 어디서 메모리가 낭비되는지 찾아내기 뭐같거든..

//     2. 메모리에 필요한 갯수만큼 가변적으로 직접 데이터를 저장하기 싫으면? 느그들 후기언어들은 그 여파를 어떻게 극복하는데?
//        : 왜 굳이 C계열처럼 직접 메모리 공간을 나눠놓고 데이터를 새겨야 하는데?
//           -> 그냥 동적으로 신축가능한 애들은 list계열로만 정해놔서 걔들만 길이조절 가능하게 만들고, 거기다가 가변적인 갯수를 가진 자료형들을 저장하면 해결되는거 아니야?  
//              -> 이걸 list라는 이름으로 class 만들어서, 또 용도별로 상속화 시켜서 입맛대로 동적array나 linkedList도 쉽게 사용되는데 얼마나 좋냐?
//                  + 이렇게 하면 쓰기 쉽고, 굳이 회수 안해도 되고, 변수 클로징도 이해하기 쉽잖아?

//     3. 메모리 할당 해제는 안 해도 좋다 치자...? 근데 만약 메모리 해제할 필요가 있어서 소멸자나 해제 명령어가 필요하면 어떻게 할건데?
//        : 가비지 콜랙터(gabbage collector) 개념으로 일정 시간마다 오래동안 안 쓰는 메모리 영역이나, {}가 종료된 지역변수들은 알아서 그 영역의 할당된 메모리가 해제하게 할거야