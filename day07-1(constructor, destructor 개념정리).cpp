// 생성자(Constructor)
//  : 객체의 [생성]과 동시에 호출하는 '클래스명'과 동일한 이름의 함수, 객체의 동적할당 연산자인 new와 함께 사용하며 초기화 과정의 편리함까지 더해줌
//    -> 원래 calloc, malloc, realloc를 대체한, 'new 클래스명'는 사실 'new 클래스명()'과 같은 의미인 기본 생성자(default Constructor) 함수 
//       (= 생성자 개념이 더 큰 개념 포함)


//   # 생성자 함수를 사용하는 이유?
//     : 동적할당 + 멤버변수 초기화가 필요한 기존의 방식 -> 생성자 하나로 그 두가지를 전부 원큐에 처리하는 방법으로 변경 + 기존 방법도 호환가능하게 변경
//     
//       - 단순 클래스 객체만 동적할당하는 기능만 활용한 기존의 방식 
//          1) class를 기반으로 한 객체를 메모리에 반영구적으로 동적할당 한뒤, 그 주소를 class 포인터 타입인 인스턴스변수에 대입
//          2) 해당 class 기반 객체의 멤버변수들을 직접 값을 넣던, setter를 쓰던 초기화함
//
//       - 생성자 함수를 활용한 기존의 방식 
//          : 멤버변수에 넣고 싶은 값을 생성자 함수 형식에 맞게 대입하면, 알아서 그 내용을 기반으로 한 class를 기반으로 한 객체를 메모리에 반영구적으로 동적할당 한뒤, 그 주소를 class 포인터 타입인 인스턴스변수에 대입함
//             -> 기존의 방식은 default constructor로 편입시켜 받아들임


//   # (중요) 생성자 특징
//     1. (공통) 멤버변수 값을 대입하는 void 함수와 비슷 (= return값 X)
//     2. (공통)가만히 있어도 parameter 없는 기본 생성자(defalut constructor)는 존재
//        -> 단! 정의부는 비어있으니, 내용은 알아서 필요하면 채워야 함
//     3. 생성자는 오버로딩(Overloading) 가능함 
//        (= parameter 구성에 따라 이론상 무한개의 생성자함수 선언도 가능)
//     4. 초기화 리스트(Initialize List) 
//         : 생성자 뒤에 콜론(:)을 사용해서 각 멤버를 초기화 할 수 있음 
//            -> (주의!) 일반 멤버함수에서는 사용 X
//     5. 객체 생성시 딱 한번 호출
//     6. (중요!) new 연산자와 함께 쓰이므로, 반드시 class 포인터변수에 대입되어야 함


//   # 생성자 함수 선언, 정의법
//
//      1. 일반적인 초기화 방법 
//          : 그냥 void 함수라고 생각하되, 생성자 함수의 존재의의 자체가 생성된 객체의 멤버변수 초기화에 있다고 생각하면 편함
//             -> 클래스명(자료형 parameter명...) { 멤버변수 = parameter 사용하거나 가공한 값 }											
//                       
//                ex) class A 멤버는 다음과 같다 가정 ( int a; double b; char c; )
//                    
//                    A (int _a, double _b, char _c) {
//                        a = _a;
//                        b = _b;
//                        c = _a;
//                    }
//
//      2. 초기화 리스트(Initialize List) 
//          : (중요!) 콜론(:)을 이용하는 초기화법, 정의부보다 우선하여 실행된다는 장점이 있어, const 멤버변수의 초기화에 쓰임                        
//             -> 클래스명(자료형 parameter명...) : 가담O 멤버변수(parameter명) , ...  { 가담X 멤버변수 = parameter 사용하거나 가공한 값 }												
//                                                            
//                ex) class A 멤버는 다음과 같다 가정 ( int a; double b; char c; )
//		          
//                    A (int _a, double _d, char _c) : a(_a), c(_c) {
//                        b = _b;
//                    }


//   # 선언, 정의한 생성자 함수 종류 및 호출법
//
//      1. defalut constructor
//
//        - defalut constructor 정의
//           : (중요!) class에 아무것도 안 적어도 무조건 기본으로 존재하는 parameter 없는 생성자함수
//              -> 단! 정의부는 비어있기에, 내용이 필요하면 채워야함
//
//        - defalut constructor 호출법
//           : 클래스명 * 클래스포인터명 = new 클래스명;     
//             클래스명 * 클래스포인터명 = new 클래스명();   
//
//             ex) point* ptr_pos_1 = new point;
//                 point* ptr_pos_1 = new point();
//
//      2. (일반) constructor
//            
//        - (일반) constructor 정의
//           : defalut constructor 이외, 오버로딩한 생성자 함수 (= parameter 구성에 따라 이론상 무한개의 생성자함수 선언도 가능함)
//              -> 보통은 parameter를 멤버변수 값으로 대입하기 위해 사용
//
//        - (일반) constructor 호출법
//           : 클래스명* 클래스포인터명 = new 클래스명(parameter....);   
//
//             ex) point* ptr_pos_1 = new point(1, 1); 


//   # 관련 의문내역 해설

//     1. 클래스명 인스턴스생성자();  vs  클래스명* 클래스포인터변수 = new 클래스생성자(); 의 차이는 뭘까? 
//        : 인스턴스객체가 저장하는 class의 객체 내용이 지역변수나 객체로서 {}가 끝나는 순간 사라지느냐? or 아니면 일종의 전역객체로서 데이터가 할당 해제나 프로그램 종료가 되기전까지 남아있냐? 여부

//     2. 클래스명 인스턴스변수명(parameters...); 방식으로 생성자 함수는 그럼 사용이 불가능한가?
//        : 사용은 가능하나... 문제는 마찬가지로 그렇게 생성되고 초기화 된 class기반 객체가 지역객체이기에 그 한계인 {}가 끝나는 순간 사라지는게 문제가 되는 것일 뿐

//           ex) point pos_1(1, 1);                    <- 해당 {}가 끝나는 순간 사라짐 (= 일반함수에서 생성 후 계산 후 보관해서 써먹겠다는 발상이 불가능
//               point* ptr_pos_1 = new point(1, 1);   <- 메모리에 사용자 임의로 동적할당해놓으라고 했기에, 프로그램 종료전까지 해제하지 않는 이상 안 없어짐
//                                                        (= return으로 class형을 받는 후기 언어들도 힙영역에 동적할당 효과는 유지하도록 조정함) 

//     3. class 객체 생성과정에서의 메모리 동적할당에 포인터가 쓰이는 것에 대한 타 언어 개발자들의 의견은? 
//        : 포인터로 선언하고 복잡하기까지 한 동적할당은 ㅈㄴ 싫음, BUT 생성자 함수를 통해 [힙영역 동적 객체생성 후 할당 + 초기화의 편의성]은 누리고 싶음
//            -> 생성자 함수의 반환값을 class타입의 레퍼런스 객체로 만들어서, 포인터 없이 class 인스턴스만 선언해도 생성자를 사용 가능하게 함(물론 힙영역에 동적메모리 할당까지 완료) + 선언한 '인스턴스객체명'으로 접근가능하게 해주는 식으로 타협을 마침
//                 -> (중요) class의 레퍼런스객체를 통한 접근으로, 동적할당한 class객체를 생성하고 접근 및 수정하는 과정에 포인터를 사용하지 않아서, 개발자들은 직관적으로 객체를 다룰 수 있게됨

//     4. (3의 연장) 그렇다면? class 포인터변수가 있을때는 포인터 연산으로 배열데이터 접근이 가능한데, 그거 없이 동적할당한 class 객체는 어떻게 접근 가능하게 저장하여 관리할거냐? + 안 쓰는 class객체에 대한 메모리 회수는 어찌 할거냐?  
//        : a. 접근은 똑같이 레버런스 객체값을 가지는 인스턴스 객체명 쓸거임
//          b. 포인터 연산으로 접근 가능한 경우, 그 데이터도 결국 메모리에 새긴 공간을 일종의 array처럼 쓰는 구조 아니냐? 
//             -> 그럼 데이터 저장과 관리도 비슷하게 컨테이너 class 객체 생성해서 제너릭스(= 템플릿)를 통해 <클래스명>에 해당하는 객체 놈들만 저장 가능하게 해서 되잖아? 
//          c. 그래서 일정시간마다 안 쓰는 객체 데이터 메모리에서 회수해주는 가비지컬랙터 쓸거야... 그러면 일일히 메모리영역에 기어들어가서 회수를 안해도 될거 아냐? 그러면 더 이상 포인터는 없어도 되는거 아님?


// 소멸자(Destructor)
//  : 객체의 [소멸]과 동시에 호출되는 '~클래스명'이란 이름의 함수, 이를 통해 'delete class객체포인터(= 객체위치 저장한 class포인터변수)'로 동적할당된 클래스 자신의 메모리 영역을 해제하면서, 다른 내용도 수행가능해짐
//     -> (중요!) 
//         1. 단! 직접 '~클래스명'를 호출해서 사용하지 않음!
//         2. class에 아무것도 안 적어도 무조건 기본으로 존재는 하는데, 멤버변수도 동적할당된 자료형이 있어서 해제해야 한다면, 정의부에 따로 delete 멤버변수 관련 내용을 적어줘야 함
//         3. 오버로딩은 불가능하며, 무조건 한가지의 소멸자만 있어야 함


//   # 소멸자 함수를 사용하는 이유?
//     : 멤버변수 중 동적할당 받은 객체와 연관되어 있는 특정 class의 포인터가 있다면, 하나하나 다 delete를 입력노가다 해야 하는 기존의 방식 
//        -> 소멸자 함수로 정의부에 동적할당된 주소값을 담는 특정 class의 포인터인 멤버변수 전부를 delete 처리하게 작성하면, class객체가 삭제될때 관련 내용들이 싹 다 사라짐


//   # (중요) 소멸자 특징
//     1. (공통) 멤버변수 값을 대입하는 void 함수와 비슷 (= return값 X)
//     2. (공통) 가만히 있어도 parameter 없는 기본 생성자(defalut constructor)는 존재
//        -> 단! 정의부는 비어있으니, 내용은 알아서 필요하면 채워야 함
//     3. 객체 삭제시 딱 한번 호출
//     4. parameter는 존재할 수 없음 (= 단 1개의 소멸자인 default 소멸자만 존재해야 함)
//     5. (중요!) 객체의 유효범위 = 지역변수의 유효범위 
//         -> 블록{}가 끝나게 되면, 자동으로 소멸자가 실행됨 (= 메모리 상에서 소멸됨)
//     6. (중요!) 직접 클래스를 호출하는 방식이 아니라, 'delete class객체포인터' 형식으로 실행됨 


//   # 소멸자 함수 선언, 정의법
//      : 그냥 void 함수라고 생각하되, 생성자 함수의 존재의의 자체가 생성된 객체의 멤버변수 초기화에 있다고 생각하면 편함
//         -> ~클래스명() { delete 멤버변수(동적할당 위치 담은 포인터인 멤버변수); }											
//                   
//            ex) class A 멤버는 다음과 같이 classCreated라는 class가 동적할당되어 있는 주소값을 가지는 포인터를 멤버변수로 둔다 가정 ( int a; classCreated* b; char c; )
//                
//                ~A () {
//                    delete b;     <- delete A의객체; 를 입력시 포인터변수인 b에 입력된 주소값에 할당된 메모리도 같이 회수함(= 잘못쓰면 연쇄 삭제 일어남..)
//                }


//   # 선언, 정의한 소멸자 함수 호출법
//      : 그냥 delete class객체포인터을 실행시 {}안에 내용도 실행해주는 void 함수라고 생각하자 (= 안 써도 해당 객체 자체는 메모리에서 해제해 줌)
//         -> delete class객체포인터;


//   # (중요!) delete 기초 사용법
//     : delete 포인터 = free(포인터)
//        -> 해당 포인터에 존재 및 연계된 포인터가 가르키는 동적할당된 객체를 제거 (애초에 동적할당을 받을떄도 포인터로 받은 위치로 구분했으니 당연한 것)


//   # 생성자 VS 소멸자 정리

//     |===========|==============================================|===============================|  
//     |           | 생성자                                       |    소멸자                     |
//     |===========|==============================================|===============================| 
//     | 호출시기  | 객체 생성시 1번만                            | 객체 소멸 시                  |
//     | 함수명    | 클래스명                                     | ~클래스명                     |
//     | 리턴값    | X                                            | X                             |
//     | 매개변수  | O (0-N개 = 생성자 오버로딩 가능)             | X (= 소멸자는 오직 1개만 존재)|
//     | 활용      | CLASS의 멤버변수 초기화 시                   | 동적 메모리 해제 시           |
//     | 사용법    | class명 포인터 = new class명(parameter..);   | delete 인스턴스(= 포인터변수) |
//     |===========|==============================================|===============================|  


//   # (부록) 후기언어에서 C언어식 동적할당 이슈
//      -> 결론 : 동적할당은 우리도 좋아 
//          -> 근데 포인터 쓰기 싫어서 포인터를 사용한 메모리 관리방식도 ㅈ같으니까! 
//          -> new는 생성된 class 객체 레퍼런스 객체로 그 자체를 뱉고 + 가비지콜랙터로 동적해제 자동화 + 제너릭스와 컨테이어 class 객체로 동적객체들 관리해서 대체할거다 이거야!

//     1. 왜 후기언어에서는자료형 동적할당 자체를 배제해버렸는데?
//        : (팩트체크!) 배제한 적 없음! 우리도 new 연산자 쓰고 생성자 호출하면, 그 class 객체가 메모리의 힙영역에 동적할당 된다 이거야!

//     2. 그럼 왜 굳이 포인터로 return하는 기존 C계열의 new 연산자의 내용을 바꾼건데? 
//        : 사용자가 임의로 메모리에 직접 데이터를 새겨넣을 수 있다는건 좋고, 메모리 위치만 알면 값을 대조할 수 있다는것도 좋음
//           -> 근데 직접 메모리에 새긴 내용들은 조상님이 알아서 지워주냐? 좀만 코드규모가 커져도 나중에는 어디서 메모리가 낭비되는지 찾아내는게 불가능에 가까운데 그거 X같아서 안 쓴다

//     3. 아니 애초에 후기언어 너그들은 왜 C계열 언어의 포인터 안 쓰는건데?
//        : 말 했다시피, 포인터를 통해 메모리를 복잡하게 다루는거 자체가 엿같고, 객체 데이터 다룰 때 직관적이지가 않아서 그래... 그래서 생성된 객체 자체를 다루도록 바꾼거지 

//     4. 그래.. 그럼 메모리 할당해제 ㅈ같고, 포인터도 ㅈ같다 치자... 근데 만약 느그들이 싸질러놓은 동적할당한 객체들 싸그리 회수(= 동적 해제)할 필요가 있어서 소멸자나 해제 명령어가 필요하면 어떻게 할건데?
//        : 가비지 콜랙터(gabbage collector) 개념으로 일정 시간마다 오래동안 안 쓰는 메모리 영역들은 알아서 그 영역의 할당된 메모리가 해제하게 할겨.. 그럼 포인터도 필요없거든? 

//     5. 그럼 느그들 후기언어들은 포인터 없이 기존에 싸질러 놓은 class 객체들을 찾을때 그놈이 누군지 혹은 어딨는지 어떻게 알고 찾을건데? 포인터가 있으면 적어도 배열시작 위치를 통해 어디서 포인터 연산이 가능한지는 알잖아?
//        : 아니! 왜 굳이 C계열처럼 직접 메모리 공간을 나눠놓고 데이터를 새겨야 하는데? 어차피 결국 그거도 메모리에 새긴 공간을 배열처럼 쓰는거잖아?
//           -> 결국 포인터도 배열에 접근하려고 쓰는거잖아? 그렇다면 배열형 컨테이너 class객체가 특정 class만 다루도록 템플릿화를 적용해서, 가변적인 갯수를 가진 class 객체들을 저장하고 배열명으로 접근가능하게 하면 해결되는거 아니야? 
//              -> 그리고 그런 구조의 컨테이너 class 계보를 만들어서, 또 용도별로 상속화 시켜서 입맛대로 동적array나 linkedList도 쉽게 사용되고 안 쓸때는 가비지콜랙터가 회수까지 알아서 해주는데 얼마나 좋냐?