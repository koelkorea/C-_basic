// 구조체(struct)
//  : 구현하려는 대상의 속성을 묶어서, 두 개 이상의 변수(자료형)를 그룹화(= 캡슐화) 한 새로운 사용자 임의로 정의한 자료형 (= 일종의 원시 class, typedef 필요없음)
//     -> c++에서는 구조체 안에 function까지 선언 및 정의가 가능해짐
// 

//   # (c++ 추가) 왜 구조체(struct)에 멤버함수를 포함하게 만들었냐?
//     1. 구조체에 멤버변수(데이터)만 묶어서 구성한다면? 그 구조체의 변수를 이용한 함수를 사용할 때에 매번 parameter를 전달해야 해서 작성이 불편하고, 프로그래머 입장에서 읽을 때 불편함이 생김..
//         -> 구조체를 만들 때 멤버함수를 같이 포함하면?
//            -> A. 호출 시에 어떤 구조체변수를 가공하는지 미리 써야하기에, 작성도 편하고 읽기도 쉬워 실수를 줄이기도 쉬움 
//               B. 호출시 기반이 되는 해당 구조체변수명의 멤버변수를 parameter 정의없이 자유로히 연산에 사용 가능 (= 같은 차원이라 볼 수 있는 구조체 영역(scope)에 존재하기에 자유로히 서로를 호출가능) 
//     2. 해당 fuction의 정의코드를 볼 때, 소속된 구조체를 볼수 있기에 함수의 목적을 파악하기 더 쉬움
//     3. fuction명 중복으로 인한 작명에 대해서도 상대적으로 자유로워짐 


//   # (c++ 추가 + 중요) 구조체(struct) 선언 형식(c++에서 추가된 기능 포함) 
//     1. 구조체 { 멤버 변수들..., 멤버 함수들 선언 + 정의 }
//         -> 각 구조체 기반 인스턴스들이 개별 멤버함수까지 포함하여 생성됨

//         ------------------------[구조체 선언 정의 구간]----------------------
//          struct 구조체명 {

//              자료형 멤버변수1;
//              자료형 멤버변수2;
//              ....
//              자료형 멤버변수n;
      
//              자료형 메서드1(parmater..) {
//                  내용..
//              }
    
//              자료형 메서드2(parmater..) {
//                  내용..
//              }
//          };

//     2. 구조체 { 멤버 변수들..., 멤버 함수들 선언 }, 멤버 함수 정의는 외부에 할 경우
//         -> 구JS의 class 함수가 static구조라 같은 클래스의 인스턴스들 모두가 공유하는 함수인 것과 유사

//         ------------------------[구조체 선언 구간]--------------------------
//           struct 구조체명 {

//              자료형 멤버변수1;
//              자료형 멤버변수2;
//              ....
//              자료형 멤버변수n;
  
//              자료형 메서드1(parmater..);        
//              자료형 메서드2(parmater..);
//          };

//         --------------------[구조체 함수 정의 구간]-------------------------
//          구조체명::메서드1(parmater..){
//                  내용..
//          }

//          구조체명::메서드2(parmater..){
//                  내용..
//          }


//   # (c++ 추가 + 중요) c++에서 :: 연산자
//     : scope resolution 연산자 (namespace, class, struct 등 자기 영역(scope)이 있는 자료형의 경우, 그 특정 자료형 안의 멤버(변수, 함수 다 포함)를 찾아 참조하라는 의미)
//       -> (결론) namespace명::식별자, 구조체명::멤버함수(), 전부 같은 맥락으로 이해하면 됨
//            -> BUT! 'namespace명::식별자'는 호출이나 참조하는 기능에 가까움     <->    구조체명::멤버함수()는 '함수 정의부'에 쓰임 ( <-> 참조는 구조체 or 클래스 변수명.멤버함수() )

//   # 구조체(struct)변수 인스턴스 선언
//      : struct 구조체명 구조체 변수명;  
//        ex) struct human man, woman;
     
//   # 구조체 초기화법
//      : struct 구조체명 구조체 변수명 = { 값1, 값2, … };
//        ex) struct human man = { "Michelin", 21 };
     
//   # 구조체의 멤버변수의 참조법
//      1. 구조체변수명.멤버변수명
//          ex) man.age
        
//      2. (c++ 추가 + 중요) 구조체변수명.메서드명(parameter가 있으면 넣음)    <->    구조체의 멤버함수 정의 : 구조체명::멤버함수(parameter.. ){ 내용 }
//         ex) man.footballPerformance();

     
//   # (주의) 구조체가 그렇다고 배열은 아니다 = 구조체변수 그 자체는 주소값을 가지지 않는다 = 포인터변수에 구조체변수만 대입할 수 없음
//     ex) struct * s_pointer = man (X)
//         struct * s_pointer = &man (O)    <- 배열이 아니라 & 사용 필요

//   # 배열 vs 구조체
//     - 공통점 : 일종의 변수 그룹
//     - 차이점 : 배열은 같은 자료형의 그룹    <->    구조체는 다양한 자료형의 재정의


// C 구조체 VS C++ 구조체 (구조체 { 멤버 변수들..., 멤버 함수들 선언 + 정의 } ) 예시
//  : ATM 구현 예시 코드를 통해 보는 차이점
#include <iostream>
using namespace std;

//-----------------------------------[C : 구조체 with 멤버변수 + 독립 함수가 parameter로 구조체값 받기]------------------------------- 

// 고객의 계좌 구조체
struct ACT_OLD {

    int ACTId;              //계좌번호
    char pw[5];             //비밀번호
    char name[20];          //이름
    int bal;                //잔액
};

// 계좌의 정보 출력 (계좌 구조체의 레퍼런스 변수를 받아서 데이터를 처리)
void showData_old(ACT_OLD& a) {
    cout << "\n계좌번호 : " << a.ACTId << endl;
    cout << a.name << " 회원님의 잔액은 " << a.bal << "입니다.\n";
}

// 계좌의 입금기능 (계좌 구조체의 레퍼런스 변수를 받아서 데이터를 처리)
void deposit_old(ACT_OLD& a) {

    int m;

    cout << "\n입금금액 입력 : ";
    cin >> m;

    // 입력한 m의 금액을 바로 멤버변수 bal에 +
    a.bal += m;
    cout << "\t\t" << m << "원 입금완료.\n";
}

// 계좌의 출금 출력 (계좌 구조체의 레퍼런스 변수를 받아서 데이터를 처리)
void withdraw_old(ACT_OLD& a) {

    int m;

    cout << "\n출금금액 입력 : ";
    cin >> m;

    // 입력한 m의 금액을 바로 멤버변수 bal에 -
    a.bal -= m;
    cout << "\t\t" << m << "원 출금완료.\n";
}

//-----------------------------------[C++ ver1 : 구조체 with  멤버함수 선언 + 정의]------------------------------- 

// 고객의 계좌 구조체
struct ACT_CPP1 {

    int ACTId;              // 계좌번호
    char pw[5];             // 비밀번호
    char name[20];          // 이름
    int bal;                // 잔액

    // 계좌의 정보 출력 (계좌 구조체의 멤버함수)
    void showData_cpp1() {
        cout << "\n계좌번호 : " << ACTId << endl;
        cout << name << " 회원님의 잔액은 " << bal << "입니다.\n";
    }

    // 계좌의 입금기능 (계좌 구조체의 멤버함수)
    void deposit_cpp1() {

        int m;

        cout << "\n입금금액 입력 : ";
        cin >> m;

        // 입력한 m의 금액을 바로 멤버변수 bal에 +
        bal += m;

        cout << "\t\t" << m << "원 입금완료.\n";
    }

    // 계좌의 출금 출력 (계좌 구조체의 멤버함수)
    void withdraw_cpp1() {

        int m;

        cout << "\n출금금액 입력 : ";
        cin >> m;

        // 입력한 m의 금액을 바로 멤버변수 bal에 -
        bal -= m;

        cout << "\t\t" << m << "원 출금완료.\n";
    }

};

//-----------------------------------[C++ ver2 : 구조체 with 멤버함수 선언, 정의부는 구조체 밖에서 :: 연산자 사용]------------------------------- 
//   # (c++ 추가 + 중요) c++에서 :: 연산자
//     : scope resolution 연산자 (namespace, class, struct 등 자기 영역(scope)이 있는 자료형의 경우, 그 특정 자료형 안의 멤버(변수, 함수 다 포함)를 찾아 참조하라는 의미)
//       -> (결론) namespace명::식별자, 구조체명::멤버함수(), 전부 같은 맥락으로 이해하면 됨

//------------------------[구조체 선언 구간]--------------------------
struct ACT_CPP2 {

    int ACTId;              // 계좌번호
    char pw[5];             // 비밀번호
    char name[20];          // 이름
    int bal;                // 잔액

    // (중요) 멤버함수를 선언 (정의는 구조체 외부에서)
    void showData_cpp2();  // 계좌정보 출력
    void deposit_cpp2();   // 입금 함수 & 출력
    void withdraw_cpp2();  // 출금 함수 & 출력
};

//--------------------[구조체 함수 정의 구간]-------------------------
// -> 구조체명::메서드1(parmater..) 형식 사용

void ACT_CPP2::showData_cpp2() {

    cout << "\n계좌번호 : " << ACTId << endl;
    cout << name << " 회원님의 잔액은 " << bal << "입니다.\n";
}

void ACT_CPP2::deposit_cpp2() {

    int m;

    cout << "\n입금금액 입력 : ";
    cin >> m;

    // 입력한 m의 금액을 바로 멤버변수 bal에 +
    bal += m;
    cout << "\t\t" << m << "원 입금완료.\n";
}

void ACT_CPP2::withdraw_cpp2() {

    int m;

    cout << "\n출금금액 입력 : ";
    cin >> m;

    // 입력한 m의 금액을 바로 멤버변수 bal에 -
    bal -= m;
    cout << "\t\t" << m << "원 출금완료.\n";
}



int main() {

    cout << "--------------------[기존 c언어의 구조체로 구현한 파트]--------------------\n\n";

    ACT_OLD act_1 = { 1234, "5678", "christopher", 10000 };

    showData_old(act_1);       // 잔액조회 함수 호출
    deposit_old(act_1);        // 입금함수 호출
    withdraw_old(act_1);       // 출금함수 호출
    showData_old(act_1);       // 잔액조회 함수 호출

    cout << "\n\n--------------------[c++의 구조체1(구조체에 맴버함수 선언 + 정의)로 구현한 파트]--------------------\n\n";

    ACT_CPP1 act_2 = { 4567, "1234", "kane", 60000 };

    // 구조체변수명.멤버함수명() 으로 일일히 파라미터 안 넘겨도 구조체 멤버변수간 교류가 가능 (만약 다른 외부변수가 필요하면, paramemter로 던져주면 됨) 
    act_2.showData_cpp1();       // 잔액조회 함수 호출
    act_2.deposit_cpp1();        // 입금함수 호출
    act_2.withdraw_cpp1();       // 출금함수 호출
    act_2.showData_cpp1();       // 잔액조회 함수 호출

    cout << "\n\n--------------------[c++의 구조체2(구조체에 맴버함수 선언 + 정의는 ::연산자 사용하여 외부에서)로 구현한 파트]--------------------\n\n";

    ACT_CPP2 act_3 = { 7894, "2345", "sonny", 90000 };

    // 구조체변수명.멤버함수명() 으로 일일히 파라미터 안 넘겨도 구조체 멤버변수간 교류가 가능 (만약 다른 외부변수가 필요하면, paramemter로 던져주면 됨) 
    //  <-> 구조체명::메서드1(parmater..)
    //       : 구조체 외부에서 멤버함수 정의할 때 쓰는 녀석
    act_3.showData_cpp2();       // 잔액조회 함수 호출
    act_3.deposit_cpp2();        // 입금함수 호출
    act_3.withdraw_cpp2();       // 출금함수 호출
    act_3.showData_cpp2();       // 잔액조회 함수 호출

    return 0;
}

