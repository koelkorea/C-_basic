// class 객체 포인터
//  : class 객체가 메모리의 힙영역에 위치한 시작주소가 어딘지를 저장하는 포인터변수

//   # class 객체 포인터 필요성
//     1. 이는 new 연산자와 생성자를 이용해, class 객체를 힙영역에 메모리를 동적할당하여 생성 후, 그 위치값을 받는데 사용됨
//     2. 메모리에 class객체 정보를 직접 세겨서, 사실상 {}에서 자유롭지 못한 지역객체가 아니라 전역객체처럼 접근이 가능
//     3. 필요한 class객체 개수가 가변적일때 유동적으로 그 개체를 추가/삭제가 쉬움

// class 객체배열
//  : class 객체가 여러 개 필요할 경우 배열로 선언

// class 객체 포인터 배열
//  : 말그대로 class객체포인터변수로만 이뤄진 배열
//     -> 객체포인터가 여러개 필요한 경우 사용하며, 이는 동적할당되어 생성되는 class객체가 많다는 의미로 받아들일수 있음

//   # (부록) 후기 언어들의 고민 및 아이디어
//      : class 객체배열을 동적으로 길이를 조절 가능하게 하면, 충분히 가변적으로 갯수가 증감하는 객체들을 쉽게 저장이 가능함
//        But! 개념도 복잡해지고, 그를 통해 동적할당된 메모리 영역을 하나하나 다 신경써서 뭘 하기도 ㅈㄴ 귀찮고 짜증남
//         -> (타협점) 포인터 배제하고, list만 동적신축되는 자료구조 class로 신설하자! 
//             : 그냥 동적으로 길이를 신축가능한 어떤 자료형이라도 받는 list 개념을 만들어서, 신축성 갯수가 예상디는 class객체는 여기다 저장하는 걸로 가자..
//               전역으로 쓰고 싶은 class객체 데이터들이 있다면, 걔를 전역변수로 선언하면, 굳이 포인터 쓸 필요 없잖아?


#include <iostream>
using namespace std;

class A {
    private:
        int a, b;

    public:
        A() { 
            cout << "생성자 호출\n"; 
        }

        void Set(int _a, int _b) {
            a = _a;
            b = _b;
        }

        void Show() {
            cout << "a =  " << a << ", b = " << b << endl; 
        }
};

int main() {

    // 객체 포인터(객체의 주소를 저장하는 포인터로 4 or 8 byte) 생성 및 동적할당 후 객체 시작위치 대입
    //  -> 동적 할당된 객체 메모리를 객체 포인터가 가리킴
    A* p = new A;  

    //객체 포인터로 멤버변수, 함수에 역참조 접근 시 ->로 접근
    p->Set(1, 10); 
    p->Show();

    // delete class객체포인터 
    //  -> 해당 주소에 위치한 동적할당된 class객체 해제 
    //     -> (중요) 왜 포인터를 쓰냐면, 동적할당도 메모리 주소로 구별했으니, 그 끝도 메모리 주소를 넣어야 함... free(포인터)도 똑같았음
    delete p;  

    return 0;
}
