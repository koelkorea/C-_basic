// 연산자 오버로딩 (operlator overloading)
//  : (중요!) 일반적으로 흔히 연산을 위해 사용하는 연산자(+, -, / ...)들도 사실은 'operator연산자'라는 함수명을 가지고 있는 함수와 같음
//     -> 이 녀석들의 선언부에 parameter의 구성으로 사용자가 작성한 class 객체들을 사용해서 overloading이? 가능함!!!
//        (= 사용자는 원시형 자료형을 사용한 연산자 외에도, class 객체를 사용할 시 연산자를 활용한 연산 법칙을 창조할 수 있음!!)


//   # 연산자의 종류
// 
//      1. 오버로딩 불가능한 연산자
//         - .                 : class 객체의 멤버영역에 접근하라는 의미
//         - .*                : class 객체의 멤버 포인터
//         - ::                : 범위 지정자
//         - ? true : false    : 3항 연산자
//         - sizeof            : 변수나 객체의 Byte 크기 계산
//         - typeid            : 변수나 객체의 자료형을 도출하는 RTTI 연산자
//         - static_cast       : type 정적 casting
//         - dynamic_cast      : type 동적 casting
//         - const_cast        : type 상수 casting
//         - retinterpret_cast : 포인터 type끼리 casting 허용 

//      2. class의 멤버함수로만 오버로딩 가능 연산자
//         - =   : 대입 연산자
//         - ()  : 함수 호출 연산자
//         - []  : 배열 접근 연산자
//         - ->  : 역참조하여 class 객체 멤버영역 접근 포인터 연산자

//      3. 그 외 대부분의 연산자는 비트연산자(<<, >>), 단항 연산자(++, --) 포함해서 overloading 가능
//          -> (중요) istream, ostream class의 객체인 std의 cin, cout 객체 역시 이 원리로 overloading


//   # 연산자 함수(operator function)의 특징
// 
//      1. 연산자의 함수명은 [operator + '연산자'] 형식으로 이뤄짐

//         ex) operator+(), operator*(), operator>>()

//      2. (중요!) 흔히 쓰는 '변수(객체) + 변수(객체)'와 같은 연산자는 연산자함수를 호출코드를 간추린 것이다

//         ex) 객체1.operator+(객체2)  ->   객체1 + 객체2

//      3. (중요!) 연산자함수로 호출하지 않고, 연산자만을 통해 축약호출을 한 경우에 그것이 어떤 class의 멤버연산자함수 호출인지? 전역연산자함수 호출인지 어떻게 구분하고, 우선권을 주냐?
//          -> 어떤 경우던 일단 멤버연산자함수에 해당하는 내용이 있는지 찾아볼 우선권을 부여함
 
//          - 연산자 축약 호출시, 호출할 연산자함수 찾는 로직 설명
//             a. 먼저, 연산대상 1번째에 쓰이는 대상의 자료형이나 class명을 기준으로 잡음 
//             b. 그 class의 멤버연산자함수 중 parameter로 들어가는 자료형들과 연산대상 2번째 이후의 대상의 자료형이나 class이 유사한 선언부가 있는지 체크함
//             c. 여기서 parameter 구성과 2번째 이후의 연산대상의 자료형 구성이 일치하는 멤버연산자함수 함수가 존재하는가?
//                 -> YES : 멤버연산자함수 구성으로 호출 
//                    NO  : 전역연산자함수를 뒤져봐서 있다면, 전역연산자함수로 호출함 (없으면, 컴파일 단계에서 에러로 잡아줌)     


//   # 연산자 함수(operator function) 호출 형식 case

//      1. 일반 연산자 호출
//         : (중요!) p1.operator+(p2) == p1 + p2 로 요약 가능
//             -> 문제점 : 상수는 객체나 변수가 아니라, 객체의 멤버함수를 사용할 수 없는데, 그럼 연산에 상수가 들어가는 경우는 어찌하냐?
//                 -> 단순히 모든 연산대상을 변수건 상수건 상관없이 overloading 해서 parameter로 넣어 추가 선언 및 정의하면 장떙인, 전역 연산자함수를 쓰는 이유

//         - 상수가 연산대상으로 들어가는 경우 해결책
//            : 1번째의 전역함수로의 선언 및 정의를 통해 호출하는 방법으로 해결을 더 많이 하게 됨 
//               -> 보다시피, 상수를 연산자 축약호출의 1번째 연산대상으로 쓰지 말라는 보장이 없고, 또 ㅈㄴ게 불편하게 때문임

//                   1. 1번째 parameter로 어떤 자료형의 const인 상수를 받는 전역연산자함수를 만듦
//                      (= 1번째 연산대상으로 상수를 발견하면 알아서 전역연산자 함수 중 내용에 맞게 오버로딩 된 녀석을 찾아쓰게 유도)
                     
//                   2. 연산자 축약 호출시, 절대 상수를 1번째 연산대상으로 설정해서 넣지 않는 방침을 짦
//                      (= 1번째 연산대상의 class 타입을 기준으로, parameter중 const 자료형이 들어가는 멤버연산자함수를 찾아갈 수 있게 overloading이 선행되어야 함)

//         - 함수명으로 호출
//            : 함수명이나 객체까지 명확하게 선언해야해서, 멤버함수인지 전역함수인지 혼동없이 사용자 의도대로 정확한 함수가 호출되는 장점이 있음
  
//               ex1) [멤버 연산자 함수] 호출 형식
//                     : 객체1.연산자함수명(객체2) 
                  
//                     Point p1(1, 1), p2(2, 2);
//                     Point p3 = p1.operator+(p2);
                 
//               ex2) [전역 연산자 함수] 호출
//                     : (중요!) 전역연산자함수명(객체1, 객체2) 
                    
//                     Point p1(1, 1), p2(2, 2);
//                     Point p3 = operator+(p1, p2); 
      
//         - 연산자 이용 축약호출 
//            : 비슷한 선언부의 내용이라면, 멤버함수 쪽을 우선순위로 해서 전역함수보다 우선순위를 가지고 호출되도록 유도하는 로직으로 움직임
       
//               ex) Point p1(1, 1), p2(2, 2);
//                   Point p3 = p1 + p2;         <- 모양새가 유사한 선언부라  1번째 연산대상의 class 멤버함수로나 전역함수로나 둘 다 성립된다 한다면, 1번째 연산대상의 class 멤버함수 쪽이 더 우선권을 가짐


//      2. 단항 연산자 호출
//         : (중요!) p1.operator++()     ==  ++p1
//                   p1.operator--(int)  ==  p1--  로 요약 가능

//         - 단항 연산자 종류
// 
//             1. 전치(전위) 연산자   ex) ++객체명, --객체명
//                : 해당 줄에서 먼저 ++ --가 붙은 변수나 객체에 지정된 연산(+1, -1이 예시)처리
//                   -> 그 후 변경된 값으로 다음 연산을 진행
               
//             2. 후치(후위) 연산자   ex) 객체명++, 객체명--
//                : 해당 줄에서 연산이 모두 종료된 뒤
//                   -> 그 후 ++ --가 붙은 변수나 객체에 지정된 연산(+1, -1이 예시)처리


//         - 전치(전위) 연산자 vs 후치(후위) 연산자 차이점
//            : 중첩 사용이 가능하게 설계되어 있냐? 가 쟁점
//               -> why? 후치 연산자의 경우 중첩 사용은 가독성과 예측 가능성 문제가 생기기에 허가되지 않는 경우가 많기 때문에 다른 잣대를 적용해야 함

//             1. 전치(전위) 연산자
//                 : (중요) 연산자로 중첩해서 쓰는것도 가능은 함 (물론 추천할리가 없음)
//                    -> How? 전치연산자 함수의 경우는 특수하게 반드시 [자기 자신을 'call by reference' 개념으로 반환]하게 작성하기 때문
//                            (= 자기 자신을 향한 연산을 계속 가능)
               
//                  ex) ++++++++++p1; == (++(++(++(++(++p1)))));
//                      -> [[[[p1.operator++()].operator++()].operator++())].operator++())].operator++(); 로 호출하는 것과 같음
               
//             2. 후치(후위) 연산자
//                 : 연산자로 중첩해서 써도 효과는 1번만 적용됨!
//                    -> 다른 연산자 함수와 마찬가지로 함수 내의 지역객체를 만들어서 값을 계산해 이걸 'call by value' 개념으로 원본을 복사한 값을 기반으로 반환하기 때문
//                       (= 백날 중첩해봐야 중첩해봐야 연산결과를 받아주는 놈이 없음 = 원본 대상에는 1도 문제없고 마지막 1번의 연산만 대입됨)


//         - 단항 연산자함수 함수명으로 호출
//            : 함수명이나 객체까지 명확하게 선언해야해서, 멤버함수인지 전역함수인지 혼동없이 사용자 의도대로 정확한 함수가 호출되는 장점이 있음
//               -> (중요!) parameter 무 : 유 = 전위연산자 : 후위연산자 
       
//               ex1) 전치(전위) 멤버 연산자 함수 호출
//                    Point p1(1, 1);
//                    Point p3 =  p1.operator++();
              
//               ex2) 후치(후위) 멤버 연산자 함수 호출 
//                    Point p1(1, 1);
//                    Point p3 =  p1.operator-- (int);         <- int parameter의 존재가 후위 단항 연산자임을 보여줌


//         - 단항 연산자함수 연산자 이용 축약호출
//            : 함수명이나 객체까지 명확하게 선언해야해서, 멤버함수인지 전역함수인지 혼동없이 사용자 의도대로 정확한 함수가 호출되는 장점이 있음

//               ex1) 전치(전위) 전역 연산자 함수 호출
//                    Point p1(1, 1);
//                    Point p3 =  ++p1;
//               
//               ex2) 후치(후위) 전역 연산자 함수 호출
//                    Point p1(1, 1), p2(2, 2);
//                    Point p3 = p1--;


//   # 연산자 오버로딩 (operlator overloading) 선언 및 정의 구조
//      1. 일반 연산자 오버로딩
//          : operator연산자(자료형 parameters){  내용  } 

//      2. 단항 연산자 오버로딩 
//          -> (중요!) (int parameter 무 : 유) = (전위연산자 : 후위연산자) 로 구분!
// 
//             - 전치(전위) 연산자 오버로딩
//                : operator++() {  내용  }  or   operator--() {  내용  }

//             - 후치(후위) 연산자 오버로딩
//                : operator++(자료형 parameter) {  내용  }  or   operator--(자료형 parameter) {  내용  }


//   # (중요!) 연산자 오버로딩(operator overloading)시 주의사항
//      1. 가급적 연선자의 기능을 그 어떤 사람이 보더라도 같은 의미로 통할 수 있도록 작성
//          -> 객체에 따라 같은 연산자를 다른 방식으로 처리하는 식으로 작성하지 말라는 것
//      2. 연산자 간의 우선순위와 결합성은 바뀌지 않음
//      3. defalut parameter 설정이 불가능!
//      4. (중요!) 기본 선언되어 제공되는 연산자함수나, 본래부터 있었던 class 내부의 경우에는 그 멤버 연산자함수를 오버로딩 불가능!
//          ->  전역함수의 의한 오버로딩으로 처리해서 해결 가능
// 
//              ex) istream이나 ostream 클래스의 멤버연산자함수에 대한 내용은 건들수 없음 (= 멤버함수에 의한 두 class의 비트연산자 오버로딩이 불가능)
//                   -> (중요) ostream&, istream&을 반환하는 전역 연산자함수operator<<에 의한 오버로딩으로 처리가능

//   # 전역 연산자함수를 쓰는 이유
//      1. 본래부터 있었던 class 내부의 경우에는 그 멤버 연산자함수를 오버로딩하여 추가하는 것이 불가능하기 때문임
//          -> 그래서 전역함수로 이를 채워넣는 식으로 해결함
//      2. 어떤 객체나 변수가 될 수 없는 상수가 1번째 연산대상으로 연산에 들어가는 경우에는, 멤버 연산자함수가 호출이 불가능하기 때문
//          -> 단순히 모든 연산대상을 변수건 상수건 상관없이 overloading 해서 parameter로 넣어 추가 선언 및 정의하면 장떙인, 전역 연산자함수 사용


// 연산자 오버로딩 & 단항 연산자 오버로딩 예시
class Point {

    private:
        int x, y;

    public:
        Point(int x = 0, int y = 0) : x(x), y(y) {}

        // point class 객체로 +연산을 할 경우에 대한 오버로딩
        Point operator+ (const Point& r) {

            Point temp;

            // parameter로 주어진 Point class 레버런스 객체 r의 x, y값을 연산자+ 멤버함수를 호출한 객체의 x, y값에 더하고 나서 
            //  -> 그 x,y 값을 멤버로 가진 tmp라는 point class 객체를 반환
            temp.x = this->x + r.x;
            temp.y = this->y + r.y;

            return temp;
        }

        // point class 객체로 -연산을 할 경우에 대한 오버로딩
        Point operator- (const Point& r) {

            Point temp;

            // parameter로 주어진 Point class 레버런스 객체 r의 x, y값을 연산자- 멤버함수를 호출한 객체의 x, y값에 더하고 나서 
            //  -> 그 x,y 값을 멤버로 가진 tmp라는 point class 객체를 반환
            temp.x = this->x - r.x;
            temp.y = this->y - r.y;

            return temp;
        }

        // 전치 연산자 ++ 오버로딩 (parameter가 없음)
        Point& operator++() {

            // (중요) 연산자++ 멤버함수를 호출한 객체의 x, y값에 1씩 더하고 나서
            //  -> 전치연산자는 객체 그 자신을 point 레퍼런스객체 형식으로 반환하는 특수성이 존재
            x += 1;
            y += 1;

            // (중요) 전치연산자는 반환값이 호출 객체 자기자신의 포인터를 역참조하여 호출 객체 자기자신을 반환하는 특수성이 존재
            // (= 자기 자신을 향한 연산을 계속 가능함)
            return *this;
        }

        // 후치 연산자 ++ 오버로딩 (parameter가 int가 쓰인거로 구분)
        //  -> (중요!) 후치 연산자의 경우 중첩 사용은 가독성과 예측 가능성 문제가 생기기에, 객체 자신의 레버런스변수를 반환하지 않음
        Point operator++(int) {

            Point temp;

            // 전위 연산자++ 멤버함수를 호출한 객체의 x, y값에 1씩 더하고 나서 
            //  -> 그 x,y 값을 멤버로 가진 tmp라는 point class 객체를 반환
            //     (= 원본 대상에는 1도 문제없고 마지막 1번의 연산만 대입됨)
            temp.x = x;
            temp.y = y;

            x += 1;
            y += 1;

            return temp;
    }


};